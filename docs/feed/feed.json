{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Ryan Cavanaugh",
  "language": "en",
  "home_page_url": "https://searyanc.dev/",
  "feed_url": "https://searyanc.dev/feed/feed.json",
  "description": "Ryan Cavanaugh&#39;s blog",
  "author": {
    "name": "Ryan Cavanaugh",
    "url": "https://bsky.app/profile/searyanc.dev"
  },
  "items": [{
      "id": "https://searyanc.dev/llm-accessibility/",
      "url": "https://searyanc.dev/llm-accessibility/",
      "title": "How I Use ChatGPT as an Accessibility Device",
      "content_html": "<p>In April 2023 I crashed my bicycle and broke both my wrists.\nAs you can imagine, this put quite the damper on my ability to type.\nSince my brain and mouth were still in working order, I figured that I could use speech-to-text to do most of my job, since as a dev manager, most of my time is spent either in meetings, or writing text related to my job.</p>\n<p>I started  off using the built-in speech-to-text functionality in Windows 11.\nIt's <em>quite</em> good in terms of everyday transcription; as good as the one built into my Android phone, to be sure.\nFor a lot of content like the performance reviews I was writing at the time, this was good enough as-is with some light copy editing.</p>\n<p>However, for technical content, this left a lot to be desired.\nA lot of clarity is gained with simple formatting, like putting programming terms in <code>fixed-width</code> font.\nFor talking about TypeScript in particular, there are a lot of things that are homophonic with other more common terms, such as <code>variants</code> vs <code>variance</code>.</p>\n<p>I also didn't like how the default speech-to-text dealt with punctuation.\nI write a <em>lot</em> of text every day, and my writing style is something that I feel is part of my identity.\nSeeing comments with my name attached to them, not written in my writing style, was surprisingly upsetting.\nIt felt like a doppleganger wrote my content.</p>\n<p>What I needed was for someone, or some thing, with the extra context of <em>what I was doing</em> to in order to reformat and copyedit my text exactly to my liking.</p>\n<p>I fired up ChatGPT and gave it the scenario. After repeated tweaking, I came up with this:</p>\n<blockquote>\n<p>Scenario: I am a maintainer on the TypeScript GitHub repo.</p>\n<p>I have dictated a message so its punctuation, formatting, and use of homophones may be off. Please correct the text for typographical errors and apply markdown formatting to relevant terms, such as names of variables, methods functions, or types.</p>\n<p>Do not add any extra content, preamble, or sign off, but do make corrections in cases where there is a homophone of a more common programming term in use, such as &quot;to Jason&quot; meaning &quot;toJSON&quot; in the context of JavaScript programming, or TypeScript related terms.</p>\n<p>Also apply in-situ corrections such as &quot;capital t type&quot; to &quot;Type&quot;. Always replace &quot;comma&quot; with a comma character, &quot;colon&quot; with an actual colon, &quot;dash&quot; with an actual dash, and so on.</p>\n<p>Add commas liberally if it makes the text flow better, as these are unlikely to be specified in the transcription. Be sure to correct other mistakes like your/you're errors. The message follows below the line. Reply only with the corrected message.</p>\n</blockquote>\n<p>The results of this are <em>incredibly</em> good.\nEven better, the fact that I can continually refine the prompt to make the corrected version more closely match what I would have typed is very powerful.</p>\n<p>Here's an example input produced from dictation. Errors or subpar results are <strong>annotated</strong></p>\n<blockquote>\n<p>This doesn't seem like a great <strong>trade off</strong> in general. <strong>downcasting</strong> to <strong>stringer number</strong> is useful because those types are known to have particular characteristics, but downcasting to <strong>object</strong> just leaves you worse off.</p>\n</blockquote>\n<p>ChatGPT transformed this to exactly what I wanted:</p>\n<blockquote>\n<p>This doesn't seem like a great trade-off in general. Downcasting to <code>string</code> or <code>number</code> is useful because those types are known to have particular characteristics, but downcasting to <code>object</code> just leaves you worse off than you were before in the vast majority of cases without providing any additional type safety.</p>\n</blockquote>\n<p>This regularly makes all kinds of excellent corrections that are entirely domain-specific, such as fixing &quot;bear identifier&quot; to &quot;bare identifier&quot;.</p>\n<p>I wrote a C# program to grab the active text from the current textbox using the Windows Accessibility API, pass the prewritten prompt + that text into the <code>gpt-3.5-turbo</code> API, and push the result back into the textbox.\nThen I wired up that invocation to a button on my Stream Deck</p>\n<p><img src=\"https://searyanc.dev/img/stream-deck-gpt.jpg\" alt=\"&quot;copyedit&quot; caption on a Stream Deck button with a debugger icon\" /></p>\n<p>The cost to do this is effectively free.\nAt a cost of $0.002 / 1,000 tokens, and a typical cost to reformat one comment of about 200 tokens, $1 can copy-edit 2,500 comments.</p>\n<p>I'm incredibly excited about the future of AI as something that can improve accessibility more generally, but even now that I can type again, I expect to use this workflow more regularly because it's just <em>faster</em>.</p>\n",
      "date_published": "2023-05-28T00:00:00Z"
    },{
      "id": "https://searyanc.dev/posts/scadr/",
      "url": "https://searyanc.dev/posts/scadr/",
      "title": "scadr: renders multi-part OpenSCAD files",
      "content_html": "<p>This solves a few very annoying problems:</p>\n<blockquote>\n<p>Given an OpenSCAD file that produces multiple parts, how do I get an <code>.stl</code> file for each of them?</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>How do I easily make an OpenSCAD file that renders in low resolution in preview, but high resolution in output?</p>\n</blockquote>\n<p>This solution doesn't require any awkward makefiles or other scripts and can just use a module naming convention. I like it.</p>\n<p>Now live at <a href=\"https://github.com/SeaRyanC/scadr#readme\">https://github.com/SeaRyanC/scadr#readme</a></p>\n",
      "date_published": "2023-05-27T00:00:00Z"
    },{
      "id": "https://searyanc.dev/victory-g-code/",
      "url": "https://searyanc.dev/victory-g-code/",
      "title": "Final Fantasy Victory G-code",
      "content_html": "<p>Almost every 3D printer supports monophonic beeps. You can use this to have it play a little tune when your print is done. Of course, the best song you can play is the opening riff from the <a href=\"https://www.youtube.com/watch?v=PZ_7ipJ6Cx8\">Final Fantasy victory fanfare</a>.</p>\n<p>In Cura, go here:</p>\n<ul>\n<li>Preferences</li>\n<li>Printers</li>\n<li>(Your printer)</li>\n<li>Machine Settings</li>\n<li>End G-code</li>\n</ul>\n<p>and append these commands to the bottom:</p>\n<pre><code>M300 P68 S156\nM300 P63 S196\nM300 P68 S233\nM300 P68 S156\nM300 P68 S196\nM300 P68 S233\nM300 P63 S311\nM300 P68 S392\nM300 P68 S466\nM300 P68 S622\nM300 P68 S784\nM300 P63 S932\nM300 P135 S1245\nM300 P135 S1245\nM300 P130 S1245\nM300 P401 S1245\nM300 P401 S988\nM300 P401 S1109\nM300 P266 S1245\nM300 P130 S1109\nM300 P1203 S1245\nG04 10\n</code></pre>\n<p>I used <a href=\"https://alexyu132.github.io/midi-m300/\">this converter</a> with <a href=\"https://thefinalfantasy.net/ff1/music-midi.html\">this MIDI file</a>. The <code>G04 10</code> (10ms delay) at the end prevents the speaker from glitching out during the last held note.</p>\n",
      "date_published": "2023-05-27T00:00:00Z"
    },{
      "id": "https://searyanc.dev/firaga-io/",
      "url": "https://searyanc.dev/firaga-io/",
      "title": "firaga.io: planner for pixel-based arts and crafts",
      "content_html": "<p>Check it out at <a href=\"https://firaga.io/\">https://firaga.io/</a></p>\n",
      "date_published": "2023-05-22T00:00:00Z"
    }
  ]
}
